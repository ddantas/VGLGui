"""
    ************************************************************************
    ***                                                                  ***
    ***            Source code generated by interpretador.pl             ***
    ***                       (OpenCV wrappers)                         ***
    ***                                                                  ***
    ***                        Please do not edit                        ***
    ***                                                                  ***
    ************************************************************************
"""
#!/usr/bin/python3 python3

import cv2
import vgl_lib as vl
import numpy as np

"""
    /** Convolution of src image by 3x3 blur mask. Result is stored in dst image.
*/    
"""
def vglCvBlurSq3(img_input, img_output):

    vl.vglCheckContext(img_input, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())

    img_output.ipl = cv2.blur(img_input.ipl, (3, 3))

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Convolution of src image by mask. Result is stored in dst image.
*/    
"""
def vglCvConvolution(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglCvConvolution: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglCvConvolution: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    expected = int(window_size_y) * int(window_size_x)
    kernel = convolution_window[:expected].reshape(int(window_size_y), int(window_size_x)).astype(np.float32)
    img_output.ipl = cv2.filter2D(img_input.ipl, -1, kernel)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Direct copy from src to dst.
*/    
"""
def vglCvCopy(img_input, img_output):

    vl.vglCheckContext(img_input, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())

    img_output.ipl = img_input.ipl.copy()

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Dilation of src image by mask. Result is stored in dst image.
*/    
"""
def vglCvDilate(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglCvDilate: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglCvDilate: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    expected = int(window_size_y) * int(window_size_x)
    kernel = convolution_window[:expected].reshape(int(window_size_y), int(window_size_x)).astype(np.uint8)
    img_output.ipl = cv2.dilate(img_input.ipl, kernel)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Erosion of src image by mask. Result is stored in dst image.
*/    
"""
def vglCvErode(img_input, img_output, convolution_window, window_size_x, window_size_y):

    vl.vglCheckContext(img_input, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())
    # EVALUATING IF window_size_x IS IN CORRECT TYPE
    if( not isinstance(window_size_x, np.uint32) ):
        try:
            window_size_x = np.uint32(window_size_x)
        except Exception as e:
            print("vglCvErode: Error!! Impossible to convert window_size_x as a np.uint32 object.")
            print(str(e))
            exit()
    # EVALUATING IF window_size_y IS IN CORRECT TYPE
    if( not isinstance(window_size_y, np.uint32) ):
        try:
            window_size_y = np.uint32(window_size_y)
        except Exception as e:
            print("vglCvErode: Error!! Impossible to convert window_size_y as a np.uint32 object.")
            print(str(e))
            exit()

    expected = int(window_size_y) * int(window_size_x)
    kernel = convolution_window[:expected].reshape(int(window_size_y), int(window_size_x)).astype(np.uint8)
    img_output.ipl = cv2.erode(img_input.ipl, kernel)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Negative of src image. Result is stored in dst image.
*/    
"""
def vglCvInvert(img_input, img_output):

    vl.vglCheckContext(img_input, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())

    img_output.ipl = cv2.bitwise_not(img_input.ipl)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Pixel-wise maximum of two images. Result is stored in dst image.
*/    
"""
def vglCvMax(img_input1, img_input2, img_output):

    vl.vglCheckContext(img_input1, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_input2, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())

    img_output.ipl = cv2.max(img_input1.ipl, img_input2.ipl)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Pixel-wise minimum of two images. Result is stored in dst image.
*/    
"""
def vglCvMin(img_input1, img_input2, img_output):

    vl.vglCheckContext(img_input1, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_input2, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())

    img_output.ipl = cv2.min(img_input1.ipl, img_input2.ipl)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Convert from RGB to grayscale.
*/    
"""
def vglCvRgb2Gray(img_input, img_output):

    vl.vglCheckContext(img_input, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())

    img_output.ipl = cv2.cvtColor(img_input.ipl, cv2.COLOR_RGB2GRAY)
    vl.create_vglShape(img_output)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Pixel-wise subtraction of two images. Result is stored in dst image.
*/    
"""
def vglCvSub(img_input1, img_input2, img_output):

    vl.vglCheckContext(img_input1, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_input2, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())

    img_output.ipl = cv2.subtract(img_input1.ipl, img_input2.ipl)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Pixel-wise sum of two images. Result is stored in dst image.
*/    
"""
def vglCvSum(img_input1, img_input2, img_output):

    vl.vglCheckContext(img_input1, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_input2, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())

    img_output.ipl = cv2.add(img_input1.ipl, img_input2.ipl)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Swap RGB channels. Result is stored in dst image.
*/    
"""
def vglCvSwapRgb(img_input, img_output):

    vl.vglCheckContext(img_input, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(img_output, vl.VGL_RAM_CONTEXT())

    img_output.ipl = cv2.cvtColor(img_input.ipl, cv2.COLOR_RGB2BGR)

    vl.vglSetContext(img_output, vl.VGL_RAM_CONTEXT())

"""
    /** Threshold of src image by float parameter. Result is stored in dst image.
*/    
"""
def vglCvThreshold(src, dst, thresh, top):

    vl.vglCheckContext(src, vl.VGL_RAM_CONTEXT())
    vl.vglCheckContext(dst, vl.VGL_RAM_CONTEXT())
    # EVALUATING IF thresh IS IN CORRECT TYPE
    if( not isinstance(thresh, np.float32) ):
        try:
            thresh = np.float32(thresh)
        except Exception as e:
            print("vglCvThreshold: Error!! Impossible to convert thresh as a np.float32 object.")
            print(str(e))
            exit()
    # EVALUATING IF top IS IN CORRECT TYPE
    if( not isinstance(top, np.float32) ):
        try:
            top = np.float32(top)
        except Exception as e:
            print("vglCvThreshold: Error!! Impossible to convert top as a np.float32 object.")
            print(str(e))
            exit()

    thresh_val = int(float(thresh) * 255)
    top_val = int(float(top) * 255)
    _, dst.ipl = cv2.threshold(src.ipl, thresh_val, top_val, cv2.THRESH_BINARY)

    vl.vglSetContext(dst, vl.VGL_RAM_CONTEXT())

